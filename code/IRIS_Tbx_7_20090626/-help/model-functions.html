<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	<title>The IRIS Toolbox Reference Manual</title><link rel="stylesheet" type="text/css" href="IRIS_Help_Files.css"><link rel="shortcut icon" href="favicon.ico" type="image/x-icon"></head><body id="top_of_page" name="top_of_page"><div class="iris-heading"><span class="gray">The</span>IRIS<span class="gray">Toolbox</span> reference manual<div class="copyright">Copyright © 2007-2009 Jaromir Benes.</div></div><h1>Model functions</h1><div class="topic-brief">This section describes functions for model objects.</div><div class="boxed"><div class="topic-name-remark">Model functions</div><h2>Introduction</h2><p /><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed"><div class="topic-name-remark" id="list_of_keywords" name="list_of_keywords">Model functions</div><h2>List of <span>functions</span></h2>
        The functions are ordered alphabetically within each category.
        <h3>Creating model objects</h3><table><tr><td style="width:15em;"><a href="#model">model</a></td><td>Read model code file and create new model object.</td></tr></table><h3>Getting information about model objects</h3><table><tr><td style="width:15em;"><a href="#get">get</a></td><td>Access properties of model object.</td></tr><tr><td style="width:15em;"><a href="#islinear">islinear</a></td><td>True if model is declared as linear.</td></tr><tr><td style="width:15em;"><a href="#isnan">isnan</a></td><td>Check for NaNs in model object.</td></tr><tr><td style="width:15em;"><a href="#issolved">issolved</a></td><td>True for parameterisations for which solution has been successfully computed..</td></tr><tr><td style="width:15em;"><a href="#isstationary">isstationary</a></td><td>True if the model, or a combination of variables, is stationary.</td></tr><tr><td style="width:15em;"><a href="#length">length</a></td><td>Number of alternative parameterisations.</td></tr><tr><td style="width:15em;"><a href="#size">size</a></td><td>Size of the model's state space.</td></tr><tr><td style="width:15em;"><a href="#sspace">sspace</a></td><td>State-space representation of model.</td></tr><tr><td style="width:15em;"><a href="#system">system</a></td><td>Unsolved system matrices.</td></tr></table><h3>Solving models</h3><table><tr><td style="width:15em;"><a href="#chksstate">chksstate</a></td><td>Check if model equations hold for currently assigned steady state.</td></tr><tr><td style="width:15em;"><a href="#expand">expand</a></td><td>Expand model solution forward up to to t+k.</td></tr><tr><td style="width:15em;"><a href="#solve">solve</a></td><td>Compute first-order accurate reduced-form solution.</td></tr><tr><td style="width:15em;"><a href="#sstate">sstate</a></td><td>Compute steady state.</td></tr><tr><td style="width:15em;"><a href="#tcorule">tcorule</a></td><td>Time-consistent (discretionary) optimal rule.</td></tr></table><h3>Simulating models, and examining deterministic properties</h3><table><tr><td style="width:15em;"><a href="#diffsrf">diffsrf</a></td><td>Differentiate shock response functions w.r.t. selected parameters.</td></tr><tr><td style="width:15em;"><a href="#eig">eig</a></td><td>Model eigenvalues sorted in ascending order of moduli.</td></tr><tr><td style="width:15em;"><a href="#forecast">forecast</a></td><td>Unconditional and conditional forecasts.</td></tr><tr><td style="width:15em;"><a href="#icrf">icrf</a></td><td>Response function to initial conditions.</td></tr><tr><td style="width:15em;"><a href="#ifrf">ifrf</a></td><td>Frequency response function to input signals in residuals.</td></tr><tr><td style="width:15em;"><a href="#reporting">reporting</a></td><td>Evaluate reporting equations.</td></tr><tr><td style="width:15em;"><a href="#resample">resample</a></td><td>Resample from model-implied distribution.</td></tr><tr><td style="width:15em;"><a href="#simulate">simulate</a></td><td>Simulate model.</td></tr><tr><td style="width:15em;"><a href="#srf">srf</a></td><td>Response function to shocks.</td></tr></table><h3>Identifying and estimating models, and filtering data</h3><table><tr><td style="width:15em;"><a href="#bn">bn</a></td><td>Beveridge-Nelson decomposition.</td></tr><tr><td style="width:15em;"><a href="#diffloglik">diffloglik</a></td><td>Score vector and information matrix for selected parameters.</td></tr><tr><td style="width:15em;"><a href="#estimate">estimate</a></td><td>Estimate model parameters by optimising selected objective function.</td></tr><tr><td style="width:15em;"><a href="#filter">filter</a></td><td>Kalman smoother and estimator of out-of-likelihood parameters.</td></tr><tr><td style="width:15em;"><a href="#fisher">fisher</a></td><td>Fisher information matrix in frequency domain.</td></tr><tr><td style="width:15em;"><a href="#loglik">loglik</a></td><td>Evaluate likelihood function in time domain.</td></tr></table><h3>Examining second-moment properties</h3><table><tr><td style="width:15em;"><a href="#acf">acf</a></td><td>Autocovariance and autocorrelation function for model variables.</td></tr><tr><td style="width:15em;"><a href="#acfd">acfd</a></td><td>Autocovariance function decomposition into contributions of shocks.</td></tr><tr><td style="width:15em;"><a href="#fevd">fevd</a></td><td>Forecast error variance decomposition for model variables.</td></tr><tr><td style="width:15em;"><a href="#ffrf">ffrf</a></td><td>Frequency response function of transition variables to measurement variables.</td></tr><tr><td style="width:15em;"><a href="#fmse">fmse</a></td><td>Forecast mean square errors.</td></tr><tr><td style="width:15em;"><a href="#vma">vma</a></td><td>VMA representation of model.</td></tr><tr><td style="width:15em;"><a href="#xsf">xsf</a></td><td>Power spectrum and spectral density function for model variables.</td></tr></table><h3>Handling data associated with models</h3><table><tr><td style="width:15em;"><a href="#db2dp">db2dp</a></td><td>Convert database to model-specific datapack.</td></tr><tr><td style="width:15em;"><a href="#dp2db">dp2db</a></td><td>Convert model-specific datapack to database.</td></tr><tr><td style="width:15em;"><a href="#emptydb">emptydb</a></td><td>Create model-specific empty database.</td></tr><tr><td style="width:15em;"><a href="#sstatedb">sstatedb</a></td><td>Model-specific steady-state database.</td></tr><tr><td style="width:15em;"><a href="#zerodb">zerodb</a></td><td>Model-specific zero database.</td></tr></table><h3>Other functions</h3><table><tr><td style="width:15em;"><a href="#assign">assign</a></td><td>Assign, or re-assign, parameters and/or steady states.</td></tr><tr><td style="width:15em;"><a href="#find">find</a></td><td>Find equations or variables or parameters by matching their labels/comments.</td></tr><tr><td style="width:15em;"><a href="#fprintf">fprintf</a></td><td>Write formatted steady-state values and/or parameters to file.</td></tr><tr><td style="width:15em;"><a href="#sprintf">sprintf</a></td><td>Write formatted steady state and/or list of parameters to string.</td></tr><tr><td style="width:15em;"><a href="#stdscale">stdscale</a></td><td>Re-scale std deviations by a common factor.</td></tr><tr><td style="width:15em;"><a href="#userdata">userdata</a></td><td>Get or set user data attached to a model object.</td></tr></table><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="acf" name="acf"><div class="topic-name-remark">Model functions</div><h2>acf</h2><div class="keyword-brief">Autocovariance and autocorrelation function for model variables.</div><h3>Syntax</h3><pre>[C,R,list] = acf(this,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>C</td><td>[<span class="">numeric</span>]</td><td>Autocovariance function matrices for measurement and transition variables.</td></tr><tr><td>R</td><td>[<span class="">numeric</span>]</td><td>Autocorrelation function matrices for measurement and transition variables.</td></tr><tr><td>list</td><td>[<span class="">cellstr</span>]</td><td>List of measurement and transition variables in the rows and columns of C and R.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model for which ACF is to be computed.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'applyto'</td><td>[<span class="">cellstr</span> | <span class="">char</span> | <span class="defaultoption">Inf</span>]</td><td>List of variables to which option 'filter' is to be applied.</td></tr><tr><td>'filter'</td><td>[<span class="">char</span> | <span class="defaultoption">empty</span>]</td><td>Apply filter based on lag operator or frequency selection to selected variables.</td></tr><tr><td>'nfreq'</td><td>[<span class="">numeric</span> | <span class="defaultoption">256</span>]</td><td>Number of equally spaced frequncies to be used with 'filter' option for numerical integration.</td></tr><tr><td>'order'</td><td>[<span class="">numeric</span> | <span class="defaultoption">0</span>]</td><td>Order up to which ACF is to be computed.</td></tr></table><h3>Description</h3><div class="description"><p>The <a href="#acf">acf</a> function returns the cross- and autocovariances for the model's measurement and transition variables, including the helper variables that capture the lags and leads necessary to write the model in its first-order autoregressive representation.</p><p>The output matrices <span class="argument">C</span> and <span class="argument">R</span> are each an <span class="math">nvar</span> × <span class="math">nvar</span> × <span class="math">(nk+1)</span> × <span class="math">nalt</span> matrix, where <span class="math">nvar</span> is the total number of measurement and transition variables, including the lags and leads needed to write the model's first-order autoregressive representation, <span class="math">nk</span> is the order up to which the ACF is to requested to be computed, and <span class="math">nalt</span> is the number of altenative parameterisations in the model object. If the model has a only single parameterisation, the matrices <span class="argument">C</span> and <span class="argument">R</span> will be, of course, 3-dimensional only.</p><p>The element <span class="argument">C</span>(<span class="math">i</span>,<span class="math">j</span>,<span class="math">k+1</span>,<span class="math">n</span>) gives you the covariance of the <span class="math">i</span>-th variable at time <span class="math">t</span> and the the <span class="math">j</span>-th variable at time <span class="math">t-k</span> in the <span class="math">n</span>-th parameterisation. <span class="argument">R</span>(<span class="math">i</span>,<span class="math">j</span>,<span class="math">k+1</span>,<span class="math">n</span>) is the corresponding correlation coefficient. You can use the <a href="other-functions.html#select">select</a> function to retrieve submatrices for a selection of variables.</p><p>The option 'filter' allows you to compute ACFs for the model's variables as if they were transformed by a linear filter. The filter is described by a text string, and can be specified either using a lag operator 'L', of referring directly to frequencies or periodicities, 'freq' and 'per', respectively. The filter can be applied only to a selection of the model's variables specified by the option 'applyto', otherwise it is applied to all of them. The filtered ACFs are calculated using the Fourier transform, and then converted back by the inverse Fourier transform. The latter involves evaluating an integral, which is done numerically by splitting the interval (0, π) into an evenly spaced grid. The number of points (256 by default) can be changed through the option 'nfreq'.</p></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="acfd" name="acfd"><div class="topic-name-remark">Model functions</div><h2>acfd</h2><div class="keyword-brief">Autocovariance function decomposition into contributions of shocks.</div><h3>Syntax</h3><pre>[C,list] = acfd(this,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>C</td><td>[<span class="">numeric</span>]</td><td>Autocovariance function matrices for measurement and transition variables broken down into contributions of individual shocks.</td></tr><tr><td>list</td><td>[<span class="">cellstr</span>]</td><td>List of measurement and transition variables in the rows and columns of C.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model for which ACF decomposition is to be computed.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'order'</td><td>[<span class="">numeric</span> | <span class="defaultoption">0</span>]</td><td>Order up to which ACF is to be computed.</td></tr></table><h3>Description</h3><div class="description"><p>This function returns the additive decomposition of each cross- and autocovariance into the contributions of the model's individual shock. Note that additive decomposition is possible only because the shocks are assumed to be uncorrelated.</p><p>C is a <span class="math">nvar</span> × <span class="math">nvar</span> × <span class="math">nk</span> × <span class="math">ne</span> × <span class="math">nalt</span> matrix, where <span class="math">nvar</span> is the number of measurement and transition variables (including their lags and leads needed to write the model's first-order autoregressive representation), <span class="math">nk</span> is the maximum requested order of the ACF, <span class="math">ne</span> is the number of shocks, and <span class="math">nalt</span> is the number of altenative parameterisations currently assigned in the model object. If the model has only a single parameterisation, then the matrix C will obviously have only 4 dimensions.</p><p>The element C(<span class="math">i</span>,<span class="math">j</span>,<span class="math">k</span>,<span class="math">l</span>,<span class="math">m</span>) gives you the contribution of the <span class="math">l</span>-th shock to the cross- or autocovariance of the <span class="math">i</span>-th variable and the <span class="math">k</span>-th lag of the <span class="math">j</span>-th variable in the <span class="math">m</span>-th parameterisation. The contributions of a shock means what the cross- or autocovariances would be if you turned off all the shocks except this one.</p><p>If you sum the elements of the matrix C in 4-th dimension for a given parameterisation <span class="math">m</span>,</p><pre>sum(C(:,:,:,:,m),4)</pre><p>you obtain precisely the cross- and autocovariances computed by the <a href="model.html#acf">acf</a> function.</p><p>You can also use the <a href="other-functions.html#select">select</a> function to retrieve the ACF decomposition submatrices for a selection of variables.</p></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="assign" name="assign"><div class="topic-name-remark">Model functions</div><h2>assign</h2><div class="keyword-brief">Assign, or re-assign, parameters and/or steady states.</div><h3>Syntax</h3><pre>[this,list] = assign(this,d)
[this,list] = assign(this,names,values)
[this,list] = assign(this,names,values,names,values,…)</pre><h3>Output arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model with newly assigned parameters and/or steady states.</td></tr><tr><td>list</td><td>[<span class="">cellstr</span>]</td><td>List of parameters and/or variables that have been successfully assigned their values and/or steady states.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model whose parameters and/or steady states are to be assigned.</td></tr><tr><td>d</td><td>[<span class="">struct</span>]</td><td>Database with parameters and/or variables and their values and/or steady states.</td></tr><tr><td>names</td><td>[<span class="">char</span> | <span class="">cellstr</span>]</td><td>List of parameter names and/or variable names and/or regular expression patterns.</td></tr><tr><td>values</td><td>[<span class="">numeric</span>]</td><td>Values and/or steady states to be assigned to the respective parameters and/or variables.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="bn" name="bn"><div class="topic-name-remark">Model functions</div><h2>bn</h2><div class="keyword-brief">Beveridge-Nelson decomposition.</div><h3>Syntax</h3><pre>[b,c] = bn(this,dpack,dates,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>b</td><td>[<span class="">struct</span> | <span class="">cell</span>]</td><td>Beveridge-Nelson permanent components of non-stationary variables.</td></tr><tr><td>c</td><td>[<span class="">struct</span> | <span class="">cell</span>]</td><td>Cumulative expected sum (linearised variables) or product (log-linearised variables) of deviations of stationary variables from their steady state.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model to be evaluated.</td></tr><tr><td>dpack</td><td>[<span class="">cell</span>]</td><td>Input datapack with initial conditions.</td></tr><tr><td>dates</td><td>[<span class="">numeric</span>]</td><td>Date(s) for which decomposition is to be computed, IRIS serial date numbers.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="chksstate" name="chksstate"><div class="topic-name-remark">Model functions</div><h2>chksstate</h2><div class="keyword-brief">Check if model equations hold for currently assigned steady state.</div><h3>Syntax</h3><pre>[flag,discrep,list] = chksstate(this,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Input arguments</h3><table><tr><td>flag</td><td>[<span class="">true</span> | <span class="">false</span>]</td><td>True if all equations hold in steady state.</td></tr><tr><td>discrep</td><td>[<span class="">cell</span>]</td><td>Discrepancies between the LHS and RHS of the model's individual equations (transition equations first, then measurement equations).</td></tr><tr><td>list</td><td>[<span class="">cellstr</span>]</td><td>List of equations with discrepancy greater than tolerance.</td></tr><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model to be checked for steady state.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'tolerance'</td><td>[<span class="">numeric</span> | <span class="defaultoption">eps^(5/9)</span>]</td><td>Tolerance when evaluating equations.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="db2dp" name="db2dp"><div class="topic-name-remark">Model functions</div><h2>db2dp</h2><div class="keyword-brief">Convert database to model-specific datapack.</div><h3>Syntax</h3><pre>dpack = db2dp(this,dbase,range)</pre><h3>Output arguments</h3><table><tr><td>dpack</td><td>[<span class="">cell</span>]</td><td>Output datapack.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model for which datapack is to be created.</td></tr><tr><td>dbase</td><td>[<span class="">struct</span>]</td><td>Input database.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers (IRIS serial date numbers).</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="diffloglik" name="diffloglik"><div class="topic-name-remark">Model functions</div><h2>diffloglik</h2><div class="keyword-brief">Score vector and information matrix for selected parameters.</div><h3>Syntax</h3><pre>[mloglik,score,info] = diffloglik(this,dbase,range,plist,<a href="hints-and-tips.html#optional-input-arguments">...</a>)
[mloglik,score,info] = diffloglik(this,dpack,plist,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>mloglik</td><td>[<span class="">numeric</span>]</td><td>Minus log-likelihood.</td></tr><tr><td>score</td><td>[<span class="">numeric</span>]</td><td>Score vector.</td></tr><tr><td>info</td><td>[<span class="">numeric</span>]</td><td>Information matrix.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model to evaluate data on.</td></tr><tr><td>plist</td><td>[<span class="">cellstr</span> | <span class="">char</span>]</td><td>List of parameters for which score and information matrix are to be computed.</td></tr><tr><td>dbase</td><td>[<span class="">struct</span>]</td><td>Database to be evaluated.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr><tr><td>dpack</td><td>[<span class="">cell</span>]</td><td>Datapack to be evaluated.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'chkexact'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Check if the shocks are exactly identified. Applies only with 'initcond' set to 'fixed'.</td></tr><tr><td>'chkfmse'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Check each forecast MSE matrix and use generalised inverse if singular.</td></tr><tr><td>'deviation'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Input and output data are deviations from steady state.</td></tr><tr><td>'domain'</td><td>[<span class="defaultoption">'time'</span> | <span class="">'freq'</span>]</td><td>Evaluate likelihood function in time or frequency domain.</td></tr><tr><td>'dtrends'</td><td>[<span class="defaultoption">'auto'</span> | <span class="">true</span> | <span class="">false</span>]</td><td>Input and output data for measurement variables include deterministic trends.</td></tr><tr><td>'exclude'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>List of measurement variables to be excluded from the objective function.</td></tr><tr><td>'initcond'</td><td>[<span class="">'fixed'</span> | <span class="">'optimal'</span> | <span class="defaultoption">'stochastic'</span>]</td><td>Stationary initial conditions have asymptotic distributions or are treated as fixed numbers.</td></tr><tr><td>'objective'</td><td>[<span class="defaultoption">'mloglik'</span> | <span class="">'prederr'</span> | <span class="">function_handle</span>]</td><td>Objective function to be optimised.</td></tr><tr><td>'objectivesample'</td><td>[<span class="defaultoption">Inf</span> | <span class="">numeric</span>]</td><td>Sub-sample on which the objective function is to be computed.</td></tr><tr><td>'outoflik'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>List of parameters on deterministic trends to be estimated by concentrating them out of likelihood function.</td></tr><tr><td>'precision'</td><td>[<span class="">'double'</span> | <span class="">'single'</span> | <span class="defaultoption">get(this,'precision')</span>]</td><td>Numerical precision of prediction and smoothing datapacks.</td></tr><tr><td>'relative'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Scale MSE matrices by estimated variance factor.</td></tr><tr><td>'weighting'</td><td>[<span class="">numeric</span> | <span class="defaultoption">empty</span>]</td><td>Weighting matrix (or vector) for objective functions based on prediction errors, see option 'objective'.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="diffsrf" name="diffsrf"><div class="topic-name-remark">Model functions</div><h2>diffsrf</h2><div class="keyword-brief">Differentiate shock response functions w.r.t. selected parameters.</div><h3>Syntax</h3><pre>s = diffsrf(this,nper,plist,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>s</td><td>[<span class="">struct</span>]</td><td>Database of time series with baseline SRF and its derivatives.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model whose shock responses are to be evaluated.</td></tr><tr><td>nper</td><td>[<span class="">numeric</span>]</td><td>Number of periods to simulate.</td></tr><tr><td>plist</td><td>[<span class="">cellstr</span> | <span class="">char</span>]</td><td>List of parameters w.r.t. which to differentiate SRFs.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'log'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Delogarithmise respones of log-linear variables.</td></tr><tr><td>'select'</td><td>[<span class="">cellstr</span> | <span class="">char</span> | <span class="defaultoption">Inf</span>]</td><td>Compute SRF for selected shocks only.</td></tr><tr><td>'size'</td><td>[<span class="">numeric</span> | <span class="defaultoption">'std'</span>]</td><td>Size of shocks.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="dp2db" name="dp2db"><div class="topic-name-remark">Model functions</div><h2>dp2db</h2><div class="keyword-brief">Convert model-specific datapack to database.</div><h3>Syntax</h3><pre>dbase = dp2db(this,dpack,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>dbase</td><td>[<span class="">struct</span>]</td><td>Output database crated from input datapack.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model on which datapack is based.</td></tr><tr><td>dpack</td><td>[<span class="">cell</span>]</td><td>Model-specific datapack.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'include'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Include initial conditions.</td></tr><tr><td>'merge'</td><td>[<span class="">struct</span> | <span class="defaultoption">empty</span>]</td><td>Merge output database with existing database.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="eig" name="eig"><div class="topic-name-remark">Model functions</div><h2>eig</h2><div class="keyword-brief">Model eigenvalues sorted in ascending order of moduli.</div><h3>Syntax</h3><pre>x = eig(this)</pre><h3>Output arguments</h3><table><tr><td>x</td><td>[<span class="">numeric</span>]</td><td>Eigenvalues, including unstable ones, sorted in ascending order of moduli.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model whose eigenvalues are requested.</td></tr><tr><td>alt</td><td>[<span class="">numeric</span> | <span class="">logical</span>]</td><td>Index of parameterisations for which vectors of eigenvalues are to be returned.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="emptydb" name="emptydb"><div class="topic-name-remark">Model functions</div><h2>emptydb</h2><div class="keyword-brief">Create model-specific empty database.</div><h3>Syntax</h3><pre>d = emptydb(this)</pre><h3>Output arguments</h3><table><tr><td>d</td><td>[<span class="">struct</span>]</td><td>Database with empty field for each model variable and parameter.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model on which database is to be based.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="estimate" name="estimate"><div class="topic-name-remark">Model functions</div><h2>estimate</h2><div class="keyword-brief">Estimate model parameters by optimising selected objective function.</div><h3>Syntax</h3><pre>[pstar,obj,grad,hess,m,se2,F,pe,delta,Pdelta,void,pred,smooth] = estimate(m,dpack,p,<a href="hints-and-tips.html#optional-input-arguments">...</a>)
[pstar,obj,grad,hess,m,se2,F,pe,delta,Pdelta,void,pred,smooth] = estimate(m,dbase,range,p,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>pstar</td><td>[<span class="">struct</span>]</td><td>Database with point estimates of requested parameters.</td></tr><tr><td>mloglik</td><td>[<span class="">numeric</span>]</td><td>Value of objective function.</td></tr><tr><td>grad</td><td>[<span class="">numeric</span>]</td><td>Gradient at optimum.</td></tr><tr><td>hess</td><td>[<span class="">cell</span>]</td><td>Hessian of log-posterior, and Hessian of log-prior (or penalty function) at optimum.</td></tr><tr><td>obj</td><td>[<span class="">numeric</span>]</td><td>Value of objective function (minus log-likelihood or weighted sum of prediction errors).</td></tr><tr><td>se2</td><td>[<span class="">numeric</span>]</td><td>Estimated common variance factor (when option 'relative' is true).</td></tr><tr><td>F</td><td>[<span class="">numeric</span>]</td><td>Prediction MSE matrices.</td></tr><tr><td>pe</td><td>[<span class="">numeric</span>]</td><td>Prediction errors.</td></tr><tr><td>delta</td><td>[<span class="">struct</span>]</td><td>Database with point estimates of out-of-likelihood parameters.</td></tr><tr><td>void</td><td>[]</td><td>Void output argument.</td></tr><tr><td>pedind</td><td>[<span class="">struct</span>]</td><td>Internal data exchange placeholder.</td></tr><tr><td>pred</td><td>[<span class="">cell</span>]</td><td>Kalman predictions, consists of datapacks 'mean' and 'mse', or databases 'mean' and 'std'..</td></tr><tr><td>smooth</td><td>[<span class="">cell</span>]</td><td>Kalman smoothing, consists of datapacks 'mean' and 'mse', or databases 'mean and 'std'..</td></tr></table><h3>Input arguments</h3><table><tr><td>m</td><td>[<span class="">model</span>]</td><td>Model.</td></tr><tr><td>p</td><td>[<span class="">struct</span>]</td><td>Database with information on optimised parameters.</td></tr><tr><td>dpack</td><td>[<span class="">cell</span>]</td><td>Input datapack.</td></tr><tr><td>dbase</td><td>[<span class="">cell</span>]</td><td>Input database.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'maxIter'</td><td>[<span class="">numeric</span> | <span class="defaultoption">2000</span>]</td><td>Maximum number of iterations allowed.</td></tr><tr><td>'nosolution'</td><td>[<span class="defaultoption">'error'</span> | <span class="">'penalty'</span>]</td><td>If optimisation runs out of stability region, throw an error or return a large penalty.</td></tr><tr><td>'output'</td><td>[<span class="">'auto'</span> | <span class="">'dbase'</span> | <span class="defaultoption">'dpack'</span>]</td><td>Format of output data.</td></tr><tr><td>'penalty'</td><td>[<span class="">numeric</span> | <span class="defaultoption">0</span>]</td><td>Regularise the likelihood function with a quadratic penalty function.</td></tr><tr><td>'refresh'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Refresh dynamic links in each iteration.</td></tr><tr><td>'solve'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Re-compute solution in each iteration.</td></tr><tr><td>'sstate'</td><td>[<span class="">function_handle</span> | <span class="defaultoption">empty</span>]</td><td>Re-compute stead state in each iteration using this function.</td></tr><tr><td>'tolFun'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1e-8</span>]</td><td>Termination tolerance on log-likehood function.</td></tr><tr><td>'tolX'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1e-8</span>]</td><td>Termination tolerance on optimised parameters.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;">for controlling objective function evaluation</span></h3><table><tr><td>'chkexact'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Check if the shocks are exactly identified. Applies only with 'initcond' set to 'fixed'.</td></tr><tr><td>'chkfmse'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Check each forecast MSE matrix and use generalised inverse if singular.</td></tr><tr><td>'deviation'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Input and output data are deviations from steady state.</td></tr><tr><td>'domain'</td><td>[<span class="defaultoption">'time'</span> | <span class="">'freq'</span>]</td><td>Evaluate likelihood function in time or frequency domain.</td></tr><tr><td>'dtrends'</td><td>[<span class="defaultoption">'auto'</span> | <span class="">true</span> | <span class="">false</span>]</td><td>Input and output data for measurement variables include deterministic trends.</td></tr><tr><td>'exclude'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>List of measurement variables to be excluded from the objective function.</td></tr><tr><td>'initcond'</td><td>[<span class="">'fixed'</span> | <span class="">'optimal'</span> | <span class="defaultoption">'stochastic'</span>]</td><td>Stationary initial conditions have asymptotic distributions or are treated as fixed numbers.</td></tr><tr><td>'objective'</td><td>[<span class="defaultoption">'mloglik'</span> | <span class="">'prederr'</span> | <span class="">function_handle</span>]</td><td>Objective function to be optimised.</td></tr><tr><td>'objectivesample'</td><td>[<span class="defaultoption">Inf</span> | <span class="">numeric</span>]</td><td>Sub-sample on which the objective function is to be computed.</td></tr><tr><td>'outoflik'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>List of parameters on deterministic trends to be estimated by concentrating them out of likelihood function.</td></tr><tr><td>'precision'</td><td>[<span class="">'double'</span> | <span class="">'single'</span> | <span class="defaultoption">get(this,'precision')</span>]</td><td>Numerical precision of prediction and smoothing datapacks.</td></tr><tr><td>'relative'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Scale MSE matrices by estimated variance factor.</td></tr><tr><td>'weighting'</td><td>[<span class="">numeric</span> | <span class="defaultoption">empty</span>]</td><td>Weighting matrix (or vector) for objective functions based on prediction errors, see option 'objective'.</td></tr></table><h3>Description</h3><div class="description"><p>The 3rd output argument is a cell array of two matrices. The first one, hess{1}, is the Hessian of the log-posterior distribution at the optimum. If you don't use any prior distributions or the penalty function, this is just the Hessian of the log-likelihood function. The second one, hess{2}, is the Hessian of the log-prior distribution, or the penalty function. If you don't use these, the second matrix is just zeros.</p></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="expand" name="expand"><div class="topic-name-remark">Model functions</div><h2>expand</h2><div class="keyword-brief">Expand model solution forward up to to t+k.</div><h3>Syntax</h3><pre>this = expand(this,k)</pre><h3>Output arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model with solution expanded forward to t+k.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model whose solution is to be expanded.</td></tr><tr><td>k</td><td>[<span class="">numeric</span>]</td><td>Horizon of forward expansion, i.e. up to t+k.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="fevd" name="fevd"><div class="topic-name-remark">Model functions</div><h2>fevd</h2><div class="keyword-brief">Forecast error variance decomposition for model variables.</div><h3>Syntax</h3><pre>[X,Y,list,x,y] = fevd(this,nper)
[X,Y,list,x,y] = fevd(this,range)</pre><h3>Output arguments</h3><table><tr><td>X</td><td>[<span class="">numeric</span>]</td><td>Forecast error variance decomposition matrices, absolute contributions of shocks.</td></tr><tr><td>Y</td><td>[<span class="">numeric</span>]</td><td>Forecast error variance decomposition matrices, relative contributions of shocks.</td></tr><tr><td>list</td><td>[<span class="">cell</span>]</td><td>List of variables in rows and list of residuals in columns of X and Y.</td></tr><tr><td>x</td><td>[<span class="">tseries</span>]</td><td>Database with time series of absolute contributions.</td></tr><tr><td>y</td><td>[<span class="">tseries</span>]</td><td>Database with time series of relative contributions.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Solved model.</td></tr><tr><td>nper</td><td>[<span class="">numeric</span>]</td><td>Number of periods.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="ffrf" name="ffrf"><div class="topic-name-remark">Model functions</div><h2>ffrf</h2><div class="keyword-brief">Frequency response function of transition variables to measurement variables.</div><h3>Syntax</h3><pre>[F,list] = ffrf(this,freq,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>F</td><td>[<span class="">cell</span>]</td><td>Frequency response function matrix.</td></tr><tr><td>list</td><td>[<span class="">cellstr</span>]</td><td>List of transition variables in rows of F, and list of measurement variables in columns of F.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model to be evaluated; must contain at least one measurement variable.</td></tr><tr><td>freq</td><td>[<span class="">numeric</span>]</td><td>Frequencies at which to evaluate FFRF.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'exclude'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>Measurement variables to be excluded from FFRF.</td></tr><tr><td>'maxiter'</td><td>[<span class="">numeric</span> | <span class="defaultoption">500</span>]</td><td>Maximum number of iteration when computing steady-state Kalman filter.</td></tr><tr><td>'select'</td><td>[<span class="">cellstr</span> | <span class="">char</span> | <span class="defaultoption">Inf</span>]</td><td>Return results for selected variables only.</td></tr><tr><td>'tolerance'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1e-7</span>]</td><td>Convergence criterion when computing steady-state Kalman filter.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="filter" name="filter"><div class="topic-name-remark">Model functions</div><h2>filter</h2><div class="keyword-brief">Kalman smoother and estimator of out-of-likelihood parameters.</div><h3>Syntax</h3><pre>[this,smooth,se2,delta,pe,F] = filter(this,dpack<a href="hints-and-tips.html#optional-input-arguments">...</a>)
[this,smooth,se2,delta,pe,F] = filter(this,dbase,range<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model solved with estimated parameters (see options 'relative' and 'outoflik').</td></tr><tr><td>smooth</td><td>[<span class="">cell</span> | <span class="">struct</span>]</td><td>Structure with 'mean' and 'mse' containing output datapacks,or 'mean and 'std' fields containing output databases (depending on 'output' option).</td></tr><tr><td>se2</td><td>[<span class="">numeric</span>]</td><td>Estimated common variance factor (if option 'relative' is true).</td></tr><tr><td>delta</td><td>[<span class="">struct</span>]</td><td>Database with point estimates of out-of-likelihood parameters.</td></tr><tr><td>pe</td><td>[<span class="">numeric</span> | <span class="">struct</span>]</td><td>Prediction errors associated with measurement variables.</td></tr><tr><td>f</td><td>[<span class="">struct</span>]</td><td>Std deviations of prediction errors.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr><tr><td>dpack</td><td>[<span class="">cell</span> | <span class="">numeric</span>]</td><td>Datapack or numeric array with measurement variables (organised rowwise).</td></tr><tr><td>dbase</td><td>[<span class="">struct</span>]</td><td>Database with measurement variables.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'chkexact'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Check if the shocks are exactly identified. Applies only with 'initcond' set to 'fixed'.</td></tr><tr><td>'chkfmse'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Check each forecast MSE matrix and use generalised inverse if singular.</td></tr><tr><td>'deviation'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Input and output data are deviations from steady state.</td></tr><tr><td>'domain'</td><td>[<span class="defaultoption">'time'</span> | <span class="">'freq'</span>]</td><td>Evaluate likelihood function in time or frequency domain.</td></tr><tr><td>'dtrends'</td><td>[<span class="defaultoption">'auto'</span> | <span class="">true</span> | <span class="">false</span>]</td><td>Input and output data for measurement variables include deterministic trends.</td></tr><tr><td>'exclude'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>List of measurement variables to be excluded from the objective function.</td></tr><tr><td>'initcond'</td><td>[<span class="">'fixed'</span> | <span class="">'optimal'</span> | <span class="defaultoption">'stochastic'</span>]</td><td>Stationary initial conditions have asymptotic distributions or are treated as fixed numbers.</td></tr><tr><td>'objective'</td><td>[<span class="defaultoption">'mloglik'</span> | <span class="">'prederr'</span> | <span class="">function_handle</span>]</td><td>Objective function to be optimised.</td></tr><tr><td>'objectivesample'</td><td>[<span class="defaultoption">Inf</span> | <span class="">numeric</span>]</td><td>Sub-sample on which the objective function is to be computed.</td></tr><tr><td>'outoflik'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>List of parameters on deterministic trends to be estimated by concentrating them out of likelihood function.</td></tr><tr><td>'output'</td><td>[<span class="defaultoption">'auto'</span> | <span class="">'dbase'</span> | <span class="">'dpack'</span>]</td><td>Format of output data.</td></tr><tr><td>'precision'</td><td>[<span class="">'double'</span> | <span class="">'single'</span> | <span class="defaultoption">get(this,'precision')</span>]</td><td>Numerical precision of prediction and smoothing datapacks.</td></tr><tr><td>'relative'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Scale MSE matrices by estimated variance factor.</td></tr><tr><td>'weighting'</td><td>[<span class="">numeric</span> | <span class="defaultoption">empty</span>]</td><td>Weighting matrix (or vector) for objective functions based on prediction errors, see option 'objective'.</td></tr></table><h3>Description</h3><div class="description"><p>Note that this function is basically identical to the <a href="#loglik">loglik</a> function except that
it returns only a subset of (more usual) output arguments
in different order.</p></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="find" name="find"><div class="topic-name-remark">Model functions</div><h2>find</h2><div class="keyword-brief">Find equations or variables or parameters by matching their labels/comments.</div><h3>Syntax</h3><pre>[list,list,…] = find(this,match,match,…)</pre><h3>Output arguments</h3><table><tr><td>list</td><td>[<span class="">cellstr</span>]</td><td>List of equations that match regular expression.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr><tr><td>match</td><td>[<span class="">char</span>]</td><td>Labels/comments to be matched.</td></tr></table><h3>Description</h3><div class="description"><p>The input argument(s) match can be regular expressions.</p></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="fisher" name="fisher"><div class="topic-name-remark">Model functions</div><h2>fisher</h2><div class="keyword-brief">Fisher information matrix in frequency domain.</div><h3>Syntax</h3><pre>[F,Fi,d,freq,G] = fisher(this,nper,plist<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>F</td><td>[<span class="">numeric</span>]</td><td>Fisher information matrix.</td></tr><tr><td>Fi</td><td>[<span class="">numeric</span>]</td><td>Contributions of individual frequencies.</td></tr><tr><td>d</td><td>[<span class="">numeric</span>]</td><td>Kronecker delta to multiply frequency contributions by.</td></tr><tr><td>freq</td><td>[<span class="">numeric</span>]</td><td>Frequencies at which the matrix has been evaluated.</td></tr><tr><td>G</td><td>[<span class="">numeric</span>]</td><td>Spectrum generating function matrices for observables.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model object.</td></tr><tr><td>nper</td><td>[<span class="">numeric</span>]</td><td>Sample length.</td></tr><tr><td>plist</td><td>[<span class="">cellstr</span> | <span class="">char</span>]</td><td>List of parameters for the information matrix will be computed.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'chksgf'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Check spectrum generating function at each frequency and use generalised inverse if singular.</td></tr><tr><td>'deviation'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Input and output data are deviations from steady state.</td></tr><tr><td>'display'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Report progress in calculations on the screen.</td></tr><tr><td>'refresh'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Refresh dynamic links in each iteration.</td></tr><tr><td>'solve'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Re-compute solution in each iteration.</td></tr><tr><td>'sstate'</td><td>[<span class="">function_handle</span> | <span class="defaultoption">empty</span>]</td><td>Re-compute stead state in each iteration using this function.</td></tr></table><h3>Description</h3><div class="description"><p>The current version of the <a href="#fisher">fisher</a> function does not handle models with non-stationary measurement variables, nor can it compute the information matrix with respect to parameters that occur in the <a href="model-code-language.html#!dtrends:measurement">deterministic trend</a> equations. This functionality will be added in future versions of IRIS.
</p><p>
The output matrix <span class="argument">F</span> is a frequency-domain approximate Fisher information matrix computed with respect to the parameters in the input list <span class="argument">plist</span>. Its size is <span class="math">np</span> × <span class="math">np</span> × <span class="math">nfreq</span> × <span class="math">nalt</span>, where <span class="math">np</span> is the number of parameters examined (i.e. the length of plist), <span class="math">nfreq</span> is the number of frequencies the matrix is evaluated at (see below), and <span class="math">nalt</span> is the number of alternative parameterisations in the model object <span class="argument">m</span>.
</p><p>
The output matrix <span class="argument">Fi</span> breaks down <span class="argument">F</span> into the contributions of individual frequencies. To re-construct <span class="argument">F</span> from <span class="argument">Fi</span>, each of the contributions need to be multiplied by the corresponding entry in the vector <span class="argument">d</span>,
</p><pre>F2 = zeros(size(F));
for i = 1 : length(d)
   F2 = F2 + d(i)*Fi(:,:,i);
end</pre><p>
The vector frequencies, <span class="argument">freq</span>, at which the information matrix is evaluated is given by
</p><div class="math">
2π<span class="math">j</span> / <span class="argument">nper</span>,     <span class="math">j</span> = 0, … [<span class="argument">nper</span>/2].
</div><p>
The output matrix <span class="argument">G</span> is has spectrum generating matrices for each frequency organised along 3-rd dimension.
</p></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="fmse" name="fmse"><div class="topic-name-remark">Model functions</div><h2>fmse</h2><div class="keyword-brief">Forecast mean square errors.</div><h3>Syntax</h3><pre>[X,list,x] = fmse(this,nper)
[X,list,x] = fmse(this,range)</pre><h3>Output arguments</h3><table><tr><td>X</td><td>[<span class="">numeric</span>]</td><td>Forecast mean square error matrices.</td></tr><tr><td>list</td><td>[<span class="">cellstr</span>]</td><td>List of variables in rows and columns of FMSE matrices.</td></tr><tr><td>x</td><td>[<span class="">tseries</span>]</td><td>Database with std deviations of model variables.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr><tr><td>nper</td><td>[<span class="">numeric</span>]</td><td>Number of periods.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="forecast" name="forecast"><div class="topic-name-remark">Model functions</div><h2>forecast</h2><div class="keyword-brief">Unconditional and conditional forecasts.</div><h3>Syntax</h3><pre>[f1,f2] = forecast(this,init,range,cond,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>f1</td><td>[<span class="">cell</span> | <span class="">struct</span>]</td><td>Forecast conditional upon user-supplied structural shocks.</td></tr><tr><td>f2</td><td>[<span class="">cell</span> | <span class="">struct</span>]</td><td>Forecast conditional upon user-supplied structural shocks and measurement variables.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr><tr><td>init</td><td>[<span class="">cell</span>]</td><td>Datapack containing distribution of initial condition (obtained as 'smooth' output datapack from Kalman filter).</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr><tr><td>cond</td><td>[<span class="">struct</span>]</td><td>Database with structural judgment and/or reduced-form judgment.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'anticipate'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>If true, future judgment is anticipated.</td></tr><tr><td>'deviation'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Input and output data are deviations from steady state.</td></tr><tr><td>'initcond'</td><td>[<span class="defaultoption">data</span> | <span class="">fixed</span> | <span class="">numeric</span>]</td><td>How to treat uncertainty in initial condition.</td></tr><tr><td>'output'</td><td>[<span class="defaultoption">'auto'</span> | <span class="">'dbase'</span> | <span class="">'dpack'</span>]</td><td>Format of output data.</td></tr><tr><td>'precision'</td><td>[<span class="defaultoption">'double'</span> | <span class="">'single'</span>]</td><td>Numerical precision of output data.</td></tr><tr><td>'std'</td><td>[<span class="">struct</span> | <span class="defaultoption">empty</span>]</td><td>Database with potentially time-varying std deviations to overwrite currently assigned std deviations.</td></tr></table><h3>Description</h3><div class="description"><p>Structural judgment means setting some of the structural shocks (residuals) to non-zero values on the forecast horizon.</p><p>Reduced-form judgment means conditioning the forecast upon specific paths imposed on some of the measurement variables.</p></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="fprintf" name="fprintf"><div class="topic-name-remark">Model functions</div><h2>fprintf</h2><div class="keyword-brief">Write formatted steady-state values and/or parameters to file.</div><h3>Syntax</h3><pre>fprintf(this,fname,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model object.</td></tr><tr><td>fname</td><td>[<span class="">char</span>]</td><td>File name.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'esstate'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Include steady states of residuals.</td></tr><tr><td>'format'</td><td>[<span class="">char</span> | <span class="defaultoption">'%.16g'</span>]</td><td>Numeric format.</td></tr><tr><td>'parameters'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Include parameters.</td></tr><tr><td>'prefix'</td><td>[<span class="">char</span> | <span class="defaultoption">'p.'</span>]</td><td>Prefix before names of parameters or variables.</td></tr><tr><td>'xsstate'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Include steady states of transitions variables.</td></tr><tr><td>'ySstate'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Include steady states of measurement variables.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="get" name="get"><div class="topic-name-remark">Model functions</div><h2>get</h2><div class="keyword-brief">Access properties of model object.</div><h3>Syntax</h3><pre>[value,value,…] = get(this,name,name,…)</pre><h3>Output arguments</h3><table><tr><td>value</td><td>[<span class="">char</span>]</td><td>Value of requested property.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model to be queried.</td></tr><tr><td>name</td><td>[<span class="">char</span>]</td><td>Name of requested property.</td></tr></table><h3>Accessible properties</h3><table><tr><td>'activeShocks'</td><td>[<span class="">cell</span>]</td><td>List of shocks with non-zero std deviations.</td></tr><tr><td>'baseYear'</td><td>[<span class="">numeric</span>]</td><td>Base year for deterministic time trends in measurement variables.</td></tr><tr><td>'dEquations'</td><td>[<span class="">struct</span>]</td><td>Deterministic trend equations for measurement variables.</td></tr><tr><td>'dTrends'</td><td>[<span class="">struct</span>]</td><td>Database with effects of deterministic trends on measurement variables.</td></tr><tr><td>'eComments'</td><td>[<span class="">cellstr</span>]</td><td>Comments to residual variables.</td></tr><tr><td>'eList'</td><td>[<span class="">cellstr</span>]</td><td>List of residual variables.</td></tr><tr><td>'eig'</td><td>[<span class="">double</span>]</td><td>All eigenvalues.</td></tr><tr><td>'epsilon'</td><td>[<span class="">numeric</span>]</td><td>Step size in numerical differentiation.</td></tr><tr><td>'filename'</td><td>[<span class="">char</span>]</td><td>Name of the model code file.</td></tr><tr><td>'forward'</td><td>[<span class="">numeric</span>]</td><td>Currently available forward expansion (number of periods ahead).</td></tr><tr><td>'lEquations'</td><td>[<span class="">struct</span>]</td><td>List of dynamic links in order of appearance in the model code.</td></tr><tr><td>'links'</td><td>[<span class="">struct</span>]</td><td>Database with dynamic links associated with the individual variables and parameters.</td></tr><tr><td>'logList'</td><td>[<span class="">cellstr</span>]</td><td>List of log-linearised variables.</td></tr><tr><td>'log'</td><td>[<span class="">struct</span>]</td><td>Database with "true" for log-linearised variables and "false" for linearised variables.</td></tr><tr><td>'nAlt'</td><td>[<span class="">numeric</span>]</td><td>Number of alternative parameterisations.</td></tr><tr><td>'nonstationaryList'</td><td>[<span class="">cellstr</span>]</td><td>List of non-stationary measurement and transition variables.</td></tr><tr><td>'omega'</td><td>[<span class="">numeric</span>]</td><td>Residual (shock) covariance matrix.</td></tr><tr><td>'pComments'</td><td>[<span class="">cellstr</span>]</td><td>List of comments to parameters.</td></tr><tr><td>'pList'</td><td>[<span class="">cellstr</span>]</td><td>List of parameters.</td></tr><tr><td>'parameters'</td><td>[<span class="">struct</span>]</td><td>Database with currently assigned parameters.</td></tr><tr><td>'rEquations'</td><td>[<span class="">cellstr</span>]</td><td>List of reporting equations.</td></tr><tr><td>'rLabels'</td><td>[<span class="">cellstr</span>]</td><td>List of labels to reporting equations.</td></tr><tr><td>'rNames'</td><td>[<span class="">cellstr</span>]</td><td>List of reporting variables.</td></tr><tr><td>'required'</td><td>[<span class="">cellstr</span>]</td><td>List of variables whose initial condition is required to simulate the model.</td></tr><tr><td>'ssGrowth'</td><td>[<span class="">struct</span>]</td><td>Currently assigned steady-state growth rates.</td></tr><tr><td>'ssLevel'</td><td>[<span class="">struct</span>]</td><td>Currently assigned steady-state levels.</td></tr><tr><td>'sstate'</td><td>[<span class="">struct</span>]</td><td>Currently assigned steady state, represented as complex numbers (real parts: levels, imaginary parts: growth rates), not including deterministic trends.</td></tr><tr><td>'stationaryList'</td><td>[<span class="">cellstr</span>]</td><td>List of stationary measurement and transition variables.</td></tr><tr><td>'stationary'</td><td>[<span class="">struct</span>]</td><td>Database with "true" for stationary variables and "false" for non-stationary variables.</td></tr><tr><td>'stdVec'</td><td>[<span class="">numeric</span>]</td><td>Vector of currently assigned std deviations.</td></tr><tr><td>'std'</td><td>[<span class="">struct</span>]</td><td>Database with currently assigned std deviations.</td></tr><tr><td>'unitRoots'</td><td>[<span class="">numeric</span>]</td><td>Eigenvalues numerically indistinguishable from 1 in magnitude.</td></tr><tr><td>'unstableRoots'</td><td>[<span class="">numeric</span>]</td><td>Eigenvalues greater than 1 in magnitude.</td></tr><tr><td>'xComments'</td><td>[<span class="">cellstr</span>]</td><td>List of comments to transition variables.</td></tr><tr><td>'xEquations'</td><td>[<span class="">cellstr</span>]</td><td>List of transition equations.</td></tr><tr><td>'xLabels'</td><td>[<span class="">cellstr</span>]</td><td>List of labels to transition equations.</td></tr><tr><td>'xList'</td><td>[<span class="">cellstr</span>]</td><td>List of transition variables.</td></tr><tr><td>'xLog'</td><td>[<span class="">logical</span>]</td><td>True for each log-linear transition variable, false otherwise.</td></tr><tr><td>'xVector'</td><td>[<span class="">cellstr</span>]</td><td>List of transition variables and their lags and leads in rows and columns of state-space transition matrix.</td></tr><tr><td>'yComments'</td><td>[<span class="">cellstr</span>]</td><td>List of comments to measurement variables.</td></tr><tr><td>'yEquations'</td><td>[<span class="">cellstr</span>]</td><td>List of measurement equations.</td></tr><tr><td>'yLabels'</td><td>[<span class="">cellstr</span>]</td><td>List of labels to measurement equations.</td></tr><tr><td>'yList'</td><td>[<span class="">cellstr</span>]</td><td>List of measurement variables.</td></tr><tr><td>'yLog'</td><td>[<span class="">logical</span>]</td><td>True for each log-linear measurement variable, false otherwise.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="icrf" name="icrf"><div class="topic-name-remark">Model functions</div><h2>icrf</h2><div class="keyword-brief">Response function to initial conditions.</div><h3>Syntax</h3><pre>[s,iclist,range] = icrf(this,nper,<a href="hints-and-tips.html#optional-input-arguments">...</a>)
[s,iclist,range] = icrf(this,range,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>s</td><td>[<span class="">struct</span>]</td><td>Database with responses of each variable to impulses in initial conditions.</td></tr><tr><td>iclist</td><td>[<span class="">cellstr</span>]</td><td>List of initial conditions.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Actual ICRF range, IRIS serial date numbers.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr><tr><td>nper</td><td>[<span class="">numeric</span>]</td><td>Number of periods.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, (IRIS serial date numbers).</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'delog'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Delog log-variables.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="ifrf" name="ifrf"><div class="topic-name-remark">Model functions</div><h2>ifrf</h2><div class="keyword-brief">Frequency response function to input signals in residuals.</div><h3>Syntax</h3><pre>[W,list] = ifrf(this,freq)</pre><h3>Output arguments</h3><table><tr><td>W</td><td>[<span class="">cell</span>]</td><td>Matrix of frequency responses of each variable to input signal in each residual.</td></tr><tr><td>list</td><td>[<span class="">cell</span>]</td><td>List of measurement and transition variables in rows of W, and list of residuals in columns W.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr><tr><td>freq</td><td>[<span class="">numeric</span>]</td><td>Vector of frequencies at which to evaluate IFRF.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="islinear" name="islinear"><div class="topic-name-remark">Model functions</div><h2>islinear</h2><div class="keyword-brief">True if model is declared as linear.</div><h3>Syntax</h3><pre>flag = islinear(this)</pre><h3>Output arguments</h3><table><tr><td>flag</td><td>[<span class="">true</span> | <span class="">false</span>]</td><td>True if model is linear.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Queried model.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="isnan" name="isnan"><div class="topic-name-remark">Model functions</div><h2>isnan</h2><div class="keyword-brief">Check for NaNs in model object.</div><h3>Syntax</h3><pre>[flag,list] = isnan(this,'parameters')
[flag,list] = isnan(this,'sstate')
[flag,index] = isnan(this,'solution')
[flag,index] = isnan(this,'expansion')</pre><h3>Output arguments</h3><table><tr><td>flag</td><td>[<span class="">true</span> | <span class="">false</span>]</td><td>True if there is at least one NaN value in requested property.</td></tr><tr><td>list</td><td>[<span class="">cellstr</span>]</td><td>List of NaN parameters (when called with 'parameters') or variables with NaN steady states (when called with 'sstate').</td></tr><tr><td>index</td><td>[<span class="">logical</span>]</td><td>Logical index detecting NaN parameterisations (when called with 'solution') or parameterisations that cannot be solved forward (when called with 'expansion').</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="issolved" name="issolved"><div class="topic-name-remark">Model functions</div><h2>issolved</h2><div class="keyword-brief">True for parameterisations for which solution has been successfully computed..</div><h3>Syntax</h3><pre>flag = issolved(this)</pre><h3>Output arguments</h3><table><tr><td>flag</td><td>[<span class="">true</span> | <span class="">false</span>]</td><td>True for each parameterisation for which solution has been successfully computed.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre>flag = issolved(m);
if any(~flag)
   warning('Solution not available for some parameterisations.');
end</pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="isstationary" name="isstationary"><div class="topic-name-remark">Model functions</div><h2>isstationary</h2><div class="keyword-brief">True if the model, or a combination of variables, is stationary.</div><h3>Syntax</h3><pre>flag = isstationary(this)
[flag,flag,…] = isstationary(this,expr,expr,…)</pre><h3>Output arguments</h3><table><tr><td>flag</td><td>[<span class="">logical</span>]</td><td>True for parameterisations, or combinations of variables, that are stationary.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Queried model.</td></tr><tr><td>expr</td><td>[<span class="">char</span>]</td><td>Linear combination of the model's variables.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="length" name="length"><div class="topic-name-remark">Model functions</div><h2>length</h2><div class="keyword-brief">Number of alternative parameterisations.</div><h3>Syntax</h3><pre>n = length(this)</pre><h3>Output arguments</h3><table><tr><td>n</td><td>[<span class="">numeric</span>]</td><td>Current number of alternative parameterisations assigned to model object.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Queried model.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="loglik" name="loglik"><div class="topic-name-remark">Model functions</div><h2>loglik</h2><div class="keyword-brief">Evaluate likelihood function in time domain.</div><h3>Syntax</h3><pre>[obj,se2,F,pe,A,Pa] = isnan(this,dpack,<a href="hints-and-tips.html#optional-input-arguments">...</a>)
[obj,se2,F,pe,A,Pa,pedind,pred,smooth] = isnan(this,dpack,<a href="hints-and-tips.html#optional-input-arguments">...</a>)
[obj,se2,F,pe,A,Pa] = isnan(this,dbase,range,<a href="hints-and-tips.html#optional-input-arguments">...</a>)
[obj,se2,F,pe,A,Pa,pedind,pred,smooth] = isnan(this,dbase,range,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>obj</td><td>[<span class="">numeric</span>]</td><td>Value of objective function (minus log-likelihood or weighted sum of prediction errors).</td></tr><tr><td>se2</td><td>[<span class="">numeric</span>]</td><td>Estimated common variance factor (when option 'relative' is true).</td></tr><tr><td>F</td><td>[<span class="">numeric</span>]</td><td>Prediction MSE matrices.</td></tr><tr><td>pe</td><td>[<span class="">numeric</span>]</td><td>Prediction errors.</td></tr><tr><td>delta</td><td>[<span class="">struct</span>]</td><td>Database with point estimates of out-of-likelihood parameters.</td></tr><tr><td>void</td><td>[]</td><td>Void output argument.</td></tr><tr><td>pedind</td><td>[<span class="">struct</span>]</td><td>Internal data exchange placeholder.</td></tr><tr><td>pred</td><td>[<span class="">cell</span>]</td><td>Kalman predictions, consists of datapacks 'mean' and 'mse', or databases 'mean' and 'std'..</td></tr><tr><td>smooth</td><td>[<span class="">cell</span>]</td><td>Kalman smoothing, consists of datapacks 'mean' and 'mse', or databases 'mean and 'std'..</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr><tr><td>dpack</td><td>[<span class="">cell</span> | <span class="">numeric</span>]</td><td>Input datapack or data array.</td></tr><tr><td>dbase</td><td>[<span class="">cell</span> | <span class="">numeric</span>]</td><td>Input database.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Time range, i.e. IRIS serial date numbers.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'chkexact'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Check if the shocks are exactly identified. Applies only with 'initcond' set to 'fixed'.</td></tr><tr><td>'chkfmse'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Check each forecast MSE matrix and use generalised inverse if singular.</td></tr><tr><td>'deviation'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Input and output data are deviations from steady state.</td></tr><tr><td>'domain'</td><td>[<span class="defaultoption">'time'</span> | <span class="">'freq'</span>]</td><td>Evaluate likelihood function in time or frequency domain.</td></tr><tr><td>'dtrends'</td><td>[<span class="defaultoption">'auto'</span> | <span class="">true</span> | <span class="">false</span>]</td><td>Input and output data for measurement variables include deterministic trends.</td></tr><tr><td>'exclude'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>List of measurement variables to be excluded from the objective function.</td></tr><tr><td>'initcond'</td><td>[<span class="">'fixed'</span> | <span class="">'optimal'</span> | <span class="defaultoption">'stochastic'</span>]</td><td>Stationary initial conditions have asymptotic distributions or are treated as fixed numbers.</td></tr><tr><td>'objective'</td><td>[<span class="defaultoption">'mloglik'</span> | <span class="">'prederr'</span> | <span class="">function_handle</span>]</td><td>Objective function to be optimised.</td></tr><tr><td>'objectivesample'</td><td>[<span class="defaultoption">Inf</span> | <span class="">numeric</span>]</td><td>Sub-sample on which the objective function is to be computed.</td></tr><tr><td>'outoflik'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>List of parameters on deterministic trends to be estimated by concentrating them out of likelihood function.</td></tr><tr><td>'output'</td><td>[<span class="">'auto'</span> | <span class="">'dbase'</span> | <span class="defaultoption">'dpack'</span>]</td><td>Format of output data.</td></tr><tr><td>'precision'</td><td>[<span class="">'double'</span> | <span class="">'single'</span> | <span class="defaultoption">get(this,'precision')</span>]</td><td>Numerical precision of prediction and smoothing datapacks.</td></tr><tr><td>'relative'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Scale MSE matrices by estimated variance factor.</td></tr><tr><td>'weighting'</td><td>[<span class="">numeric</span> | <span class="defaultoption">empty</span>]</td><td>Weighting matrix (or vector) for objective functions based on prediction errors, see option 'objective'.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;">when option 'objective' is 'prederr'</span></h3><table><tr><td>'weighting'</td><td>[<span class="">numeric</span> | <span class="defaultoption">empty</span>]</td><td>Weighting matrix (or vector) for objective functions based on prediction errors, see also the option 'objective'.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="model" name="model"><div class="topic-name-remark">Model functions</div><h2>model</h2><div class="keyword-brief">Read model code file and create new model object.</div><h3>Syntax</h3><pre>this = model(fname,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>New model object based on model code file.</td></tr></table><h3>Input arguments</h3><table><tr><td>fname</td><td>[<span class="">char</span>]</td><td>Model code file name.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'assign'</td><td>[<span class="">struct</span> | <span class="defaultoption">empty</span>]</td><td>Use this database to assign parameters and/or steady states.</td></tr><tr><td>'baseyear'</td><td>[<span class="">numeric</span> | <span class="defaultoption">2000</span>]</td><td>Base year for deterministic time trends.</td></tr><tr><td>'epsilon'</td><td>[<span class="">numeric</span> | <span class="defaultoption">eps^(1/4)</span>]</td><td>Size of step when calculating numerical derivatives (applies only if 'symbolic' is false, or if Symbolic Math Toolbox installed).</td></tr><tr><td>'linear'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Linear or non-linear model.</td></tr><tr><td>'precision'</td><td>[<span class="">'single'</span> | <span class="defaultoption">'double'</span>]</td><td>Numeric precision with which system matrices and simulation results will be stored.</td></tr><tr><td>'std'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1</span>]</td><td>Default std error of model residuals.</td></tr><tr><td>'symbolic'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Compute symbolic derivatives of model equations.</td></tr><tr><td>'userdata'</td><td>[<span class="">anything</span> | <span class="defaultoption">empty</span>]</td><td>Attach data of any kind to model.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="reporting" name="reporting"><div class="topic-name-remark">Model functions</div><h2>reporting</h2><div class="keyword-brief">Evaluate reporting equations.</div><h3>Syntax</h3><pre>d = reporting(this,d,range)</pre><h3>Output arguments</h3><table><tr><td>d</td><td>[<span class="">struct</span>]</td><td>Output database.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model with reporting equations that are to be evaluated.</td></tr><tr><td>d</td><td>[<span class="">struct</span>]</td><td>Input database.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="resample" name="resample"><div class="topic-name-remark">Model functions</div><h2>resample</h2><div class="keyword-brief">Resample from model-implied distribution.</div><h3>Syntax</h3><pre>output = resample(this,source,range,ndraw,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>output</td><td>[<span class="">cell</span> | <span class="">struct</span>]</td><td>Output datapack or database.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model to be resampled from.</td></tr><tr><td>source</td><td>[<span class="">cell</span> | <span class="">struct</span>]</td><td>Input datapack or database with shocks and/or initial conditions (if needed).</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr><tr><td>ndraw</td><td>[<span class="">numeric</span>]</td><td>Number of draws.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'deviation'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Input and output data are deviations from steady state.</td></tr><tr><td>'distribution'</td><td>[<span class="">'bootstrap'</span> | <span class="defaultoption">'normal'</span> | <span class="">function_handle</span>]</td><td>Distribution to draw shocks and/or initial conditions from.</td></tr><tr><td>'output'</td><td>[<span class="">'dbase'</span> | <span class="defaultoption">'dpack'</span>]</td><td>Output data format.</td></tr><tr><td>'randomise'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Randomise initial conditions, otherwise use unconditional mean.</td></tr><tr><td>'tolerance'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1e-5</span>]</td><td>Tolerance for setting up covariance matrix for initial conditions in non-stationary models.</td></tr><tr><td>'wild'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Use wild bootstrap, otherwise standard Efron bootstrap. Applies only if 'bootstrap' == true.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="simulate" name="simulate"><div class="topic-name-remark">Model functions</div><h2>simulate</h2><div class="keyword-brief">Simulate model.</div><h3>Syntax</h3><pre>output = simulate(this,dbase,range,<a href="hints-and-tips.html#optional-input-arguments">...</a>)
output = simulate(this,dpack,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>output</td><td>[<span class="">struct</span> | <span class="">cell</span>]</td><td>Output database or datapack.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model to be simulated.</td></tr><tr><td>dbase</td><td>[<span class="">struct</span>]</td><td>Input database (to contain initial condition, within-simulation shocks, and exogenised values).</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Simulation range, i.e. IRIS serial date numbers.</td></tr><tr><td>dpack</td><td>[<span class="">cell</span>]</td><td>Input datapack. Simulation range identical to datapack range.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'anticipate'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Future residuals and/or exogenised variables are anticipated.</td></tr><tr><td>'checkonly'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Check for availability of all required data only.</td></tr><tr><td>'contributions'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Decompose simulation into contributions of individual shocks.</td></tr><tr><td>'deviation'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Input and output data are deviations from steady state.</td></tr><tr><td>'ignoreresiduals'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Ignore any residuals found in source data.</td></tr><tr><td>'include'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Include or not initial conditions into output data.</td></tr><tr><td>'output'</td><td>[<span class="defaultoption">'auto'</span> | <span class="">'dbase'</span> | <span class="">'dpack'</span>]</td><td>Format of output data.</td></tr><tr><td>'plan'</td><td>[<span class="">plan</span> | <span class="defaultoption">empty</span>]</td><td>Simulate plan specifying exogenised variables and endogenised residuals.</td></tr></table><h3>Description</h3><div class="description"><p>
The input database <span class="argument">dbase</span>, or the input datapack <span class="argument">dpack</span>, is used to set up the initial condition and to specify the current and future shocks. No other information is taken from the input data. You, therefore, do not have to create the input database for the whole simulation range.
</p><p>
Any shocks found in the input data within the simulation range are treated according to the 'anticipate' option. If it is set to true then the model's solution is expanded forward so that all the shocks are taken into account from the very beginning. If the option is false then each shock comes as a suprise at the respective date. Furthermore, you can combine anticipated and unanticipated shocks in the following way. You set the 'anticipate' option to the baseline value, and set up the shocks as complex numbers. The real parts of them will be tretead according to what 'anticipate' is, whereas the imaginary parts will be treated the other way around. For instance, if 'anticipate' is true, and there is a future shock 0.01+0.05i in the input data, then 0.01 will be anticipated from the beginning of the simulation, and 0.05 will be an unanticipated shock. If you switch 'anticipate' to false instead then 0.05 will be anticipated, and 0.01 will come as a surprise.
</p></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="size" name="size"><div class="topic-name-remark">Model functions</div><h2>size</h2><div class="keyword-brief">Size of the model's state space.</div><h3>Syntax</h3><pre>[ny,nx,nf,nb,ne,np,nalt] = size(this)
n = size(this)</pre><h3>Output arguments</h3><table><tr><td>ny</td><td>[<span class="">numeric</span>]</td><td>Number of measurement variables.</td></tr><tr><td>nx</td><td>[<span class="">numeric</span>]</td><td>Number of state variables, nx = nf + nb.</td></tr><tr><td>nf</td><td>[<span class="">numeric</span>]</td><td>Number of unpredetermined state variables.</td></tr><tr><td>nb</td><td>[<span class="">numeric</span>]</td><td>Number of predetermined state variables.</td></tr><tr><td>ne</td><td>[<span class="">numeric</span>]</td><td>Number of residuals.</td></tr><tr><td>np</td><td>[<span class="">numeric</span>]</td><td>Number of parameters.</td></tr><tr><td>nalt</td><td>[<span class="">numeric</span>]</td><td>Number of alternative parameterisations.</td></tr><tr><td>n</td><td>[<span class="">numeric</span>]</td><td>Number of alternative parameterisations returned as n = [1,nalt].</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Queried model.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="solve" name="solve"><div class="topic-name-remark">Model functions</div><h2>solve</h2><div class="keyword-brief">Compute first-order accurate reduced-form solution.</div><h3>Syntax</h3><pre>[this,npath,eigval] = solve(this,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Solved model.</td></tr><tr><td>npath</td><td>[<span class="">numeric</span>]</td><td>Number of Blanchard-Kahn stable solutions for each parameterisation: 0, 1, or Inf.</td></tr><tr><td>eigval</td><td>[<span class="">numeric</span>]</td><td>Model eigenvalues for each parameterisation.</td></tr><tr><td>logbook</td><td>[<span class="">cell</span>]</td><td>Logbook of failed logged parameterisations since last clearance.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model to be solved.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'alt'</td><td>[<span class="">true</span> | <span class="">false</span> | <span class="defaultoption">Inf</span>]</td><td>Compute solution for the specified parameterisations only.</td></tr><tr><td>'expand'</td><td>[<span class="">numeric</span> | <span class="defaultoption">0</span>]</td><td>Expand model solution forward up to t+k.</td></tr><tr><td>'logbook'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span> | <span class="">'clear'</span>]</td><td>Log failed parameterisations.</td></tr><tr><td>'select'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Re-compute derivatives only for equations affected by changes in steady state or parameters.</td></tr><tr><td>'tolerance'</td><td>[<span class="">numeric</span> | <span class="defaultoption">eps^(5/9)</span>]</td><td>Threshold for eigenvalue test.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="sprintf" name="sprintf"><div class="topic-name-remark">Model functions</div><h2>sprintf</h2><div class="keyword-brief">Write formatted steady state and/or list of parameters to string.</div><h3>Syntax</h3><pre>s = sprintf(this,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>s</td><td>[<span class="">char</span>]</td><td>Formatted text with requested output.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model object.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'esstate'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Include steady states of residuals.</td></tr><tr><td>'format'</td><td>[<span class="">char</span> | <span class="defaultoption">'%.16g'</span>]</td><td>Numeric format.</td></tr><tr><td>'parameters'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Include parameters.</td></tr><tr><td>'prefix'</td><td>[<span class="">char</span> | <span class="defaultoption">'p.'</span>]</td><td>Prefix before names of parameters or variables.</td></tr><tr><td>'xsstate'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Include steady states of transitions variables.</td></tr><tr><td>'ySstate'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Include steady states of measurement variables.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="srf" name="srf"><div class="topic-name-remark">Model functions</div><h2>srf</h2><div class="keyword-brief">Response function to shocks.</div><h3>Syntax</h3><pre>[s,range] = srf(this,nper,<a href="hints-and-tips.html#optional-input-arguments">...</a>)
[s,range] = srf(this,range,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>s</td><td>[<span class="">struct</span> | <span class="">dbase</span>]</td><td>Database with shock responses as multivariate time series.</td></tr><tr><td>range</td><td>[<span class="">numeric</span> | <span class="">logical</span>]</td><td>Actual range, i.e. IRIS serial date numbers.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr><tr><td>nper</td><td>[<span class="">numeric</span>]</td><td>Number of periods.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'log'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Delogarithmise respones of log-linear variables.</td></tr><tr><td>'select'</td><td>[<span class="">cellstr</span> | <span class="">char</span> | <span class="defaultoption">Inf</span>]</td><td>Compute SRF for selected shocks only.</td></tr><tr><td>'size'</td><td>[<span class="">numeric</span> | <span class="defaultoption">'std'</span>]</td><td>Size of shocks.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="sspace" name="sspace"><div class="topic-name-remark">Model functions</div><h2>sspace</h2><div class="keyword-brief">State-space representation of model.</div><h3>Syntax</h3><pre>[T,R,K,Z,H,D,U,Omega,list] = sspace(this,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>T</td><td>[<span class="">numeric</span>]</td><td>Transition matrix.</td></tr><tr><td>R</td><td>[<span class="">numeric</span>]</td><td>Impact matrix of residuals in transition equations.</td></tr><tr><td>K</td><td>[<span class="">numeric</span>]</td><td>Vector of constants in transition equations.</td></tr><tr><td>Z</td><td>[<span class="">numeric</span>]</td><td>Mapping matrix between transition and measurement variables.</td></tr><tr><td>H</td><td>[<span class="">numeric</span>]</td><td>Impact matrix of residuals in measurement equations.</td></tr><tr><td>D</td><td>[<span class="">numeric</span>]</td><td>Vector of constants in measurement equations.</td></tr><tr><td>U</td><td>[<span class="">numeric</span>]</td><td>Matrix to convert the α vector to predetermined transition variables (identity matrix when option 'triangular' set to false).</td></tr><tr><td>Omega</td><td>[<span class="">numeric</span>]</td><td>Covariance matrix of residuals (always diagonal).</td></tr><tr><td>list</td><td>[<span class="">cell</span>]</td><td>List of measurement variables, list of transition variables, and list of residuals in the rows and columns of state-space matrices.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'removeinactive'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Remove shocks with zero std deviations from state-space representation.</td></tr><tr><td>'triangular'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>If true, upper-quasi-triangular representation of transition equations is returned; if false the transition equations are expressed in original predetermined variables.</td></tr></table><h3>Description</h3><div class="description"><p>The state-space form IRIS works with is as follows:</p><div class="math">[xf<sub>t</sub> ; α<sub>t</sub>] = T α<sub>t-1</sub> + K + R<sub>0</sub> e<sub>t</sub> + R<sub>1</sub> E<sub>t</sub>[e<sub>t+1</sub>] + R<sub>2</sub> E<sub>t</sub>[e<sub>t+2</sub>] + ...
y<sub>t</sub> = Z α<sub>t</sub> + D + H e<sub>t</sub>
xb<sub>t</sub> = U α<sub>t</sub></div><p>where <b>y<sub>t</sub></b> is a vector of measurement variables, <b>xf<sub>t</sub></b> and <b>xb<sub>t</sub></b> are vectors of, respectively, non-predetermined (forward-looking) and predetermined (backward-looking) transition variables, including helper variables created to deal with higher lags or leads, <b>e<sub>t</sub></b> is a vector of residuals, and <b>E<sub>t</sub>[]</b> is a conditional expectations operator. Furthermore, <b>α<sub>t</sub></b> is a vector of transformed variables found so that the resulting transition matrix <b>T</b> is upper-quasi-triangular, i.e. with 1x1 or 2x2 blocks on the main diagonal depending on the occurrence of real or complex roots. Note also that <b>T</b> is, in general, a rectangular, not a square, matrix as it maps the lag <b>α<sub>t-1</sub></b> into the current non-predetermined variables and <b>α<sub>t</sub></b>.</p><p>The matrices <b>R<sub>1</sub></b>, <b>R2<sub>2</sub></b>, etc., represent the forward expansion of a model's solution to capture the effects of future anticipated residuals. These matrices are computed only upon request or when needed in the <a href="#simulation">simulation</a> or <a href="#forecast">forecast</a> functions. See also the 'expand' option in the <a href="#solve">solve</a> function, or the <a href="#expand">expand</a> function. When the forward expansion is computed, the matrices <b>R<sub>1</sub></b>, <b>R<sub>3</sub></b>, ..., <b>R<sub>k</sub></b>, are stacked in 2nd dimension in the output argument R = [<b>R<sub>1</sub></b>, <b>R<sub>2</sub></b>, ..., <b>R<sub>k</sub></b>].
</p><p>The last output argument, <b>list</b>, is a cell array containing three cellstr arrays: the first is the list of measurement variables ordered as they appear in the rows of <b>Z</b>, <b>D</b>, and <b>H</b>, the second is the list of non-predetermined transition variables (upper part) and predetermined transition variables (lower part) ordered as they appear in the rows of the upper blocks of <b>T</b>, <b>K</b>, <b>R</b> (recall that lower parts of these matrices relate to the transformed vector <b>α</b>), and in the rows of <b>U</b>.</p></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="sstate" name="sstate"><div class="topic-name-remark">Model functions</div><h2>sstate</h2><div class="keyword-brief">Compute steady state.</div><h3>Syntax</h3><pre>[this,flag] = sstate(this,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model with newly computed steady state.</td></tr><tr><td>flag</td><td>[<span class="">logical</span>]</td><td>True for parameterisations for which convergence has been reached; always true for linear models.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model whose steady state is to be computed.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;">for non-linear models</span></h3><table><tr><td>'algorithm'</td><td>[<span class="defaultoption">'lsqnonlin'</span> | <span class="">'fsolve'</span>]</td><td>Choose one of the two Optimization Toolbox's algorithms to numerically solve the steady state of non-linear models..</td></tr><tr><td>'blocks'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Break down the model's steady-state equations into recursive blocks. Needs to be set to false when you solve the balanced-growth path of a unit-root model with some numeraires fixed..</td></tr><tr><td>'display'</td><td>[<span class="">final'</span> | <span class="defaultoption">'iter'</span> | <span class="">'notify'</span> | <span class="">'off'</span>]</td><td>Level of display.</td></tr><tr><td>'fixallbut'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>List of variables whose steady state will not be fixed. All other variables will be fixed to values currently assigned in the model object.</td></tr><tr><td>'fix'</td><td>[<span class="">cellstr</span> | <span class="defaultoption">empty</span>]</td><td>List of variables whose steady state will be fixed to values currently assigned in the model object.</td></tr><tr><td>'maxfunevals'</td><td>[<span class="">numeric</span> | <span class="defaultoption">500</span>]</td><td>Maximum number of steady-state model evaluations allowed.</td></tr><tr><td>'maxiter'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1000</span>]</td><td>Maximum number of iterations allowed.</td></tr><tr><td>'optimset'</td><td>[<span class="">struct</span> | <span class="defaultoption">empty</span>]</td><td>Modify other Optimization Toolbox options.</td></tr><tr><td>'randomise'</td><td>[<span class="">numeric</span> | <span class="defaultoption">[1,1]</span>]</td><td>Randomise starting values in given interval.</td></tr><tr><td>'tolfun'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1e-12</span>]</td><td>Termination tolerance on steady-state equation discrepancies.</td></tr><tr><td>'tolx'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1e-12</span>]</td><td>Termination tolerance on variables.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="sstatedb" name="sstatedb"><div class="topic-name-remark">Model functions</div><h2>sstatedb</h2><div class="keyword-brief">Model-specific steady-state database.</div><h3>Syntax</h3><pre>d = sstatedb(this,range,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>d</td><td>[<span class="">struct</span>]</td><td>Database with model variables as time series filled with their steady states.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model for which steady-state database is to be constructed.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'dtrends'</td><td>[<span class="defaultoption">true</span> | <span class="">false</span>]</td><td>Measurement variables will include deterministic trends.</td></tr><tr><td>'nDraw'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1</span>]</td><td>Number of randomly drawn data sets (use together with option 'residuals').</td></tr><tr><td>'residuals'</td><td>[<span class="">function_handle</span> | <span class="defaultoption">empty</span>]</td><td>Function to generate residuals.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="stdscale" name="stdscale"><div class="topic-name-remark">Model functions</div><h2>stdscale</h2><div class="keyword-brief">Re-scale std deviations by a common factor.</div><h3>Syntax</h3><pre>this = stdscale(this,factor)</pre><h3>Output arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model with newly scaled std deviations.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model whose std deviations are to be scaled.</td></tr><tr><td>factor</td><td>[<span class="">numeric</span>]</td><td>Factor by which std deviations are to be multiplied.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="system" name="system"><div class="topic-name-remark">Model functions</div><h2>system</h2><div class="keyword-brief">Unsolved system matrices.</div><h3>Syntax</h3><pre>[A,B,C,D,F,G,H,J,list,nf] = system(this)</pre><h3>Output arguments</h3><table><tr><td>A</td><td>[<span class="">numeric</span>]</td><td>Matrix for leads of transition variables in transition equations.</td></tr><tr><td>B</td><td>[<span class="">numeric</span>]</td><td>Matrix for current dates of transition variables in transition equations.</td></tr><tr><td>C</td><td>[<span class="">numeric</span>]</td><td>Vector of constants in transition equations.</td></tr><tr><td>D</td><td>[<span class="">numeric</span>]</td><td>Matrix for residuals in transition equations.</td></tr><tr><td>F</td><td>[<span class="">numeric</span>]</td><td>Matrix for measurement variables in measurement equations.</td></tr><tr><td>G</td><td>[<span class="">numeric</span>]</td><td>Matrix for predetermiend transition variables in measurement equations.</td></tr><tr><td>H</td><td>[<span class="">numeric</span>]</td><td>Vector of constants in measurement equations.</td></tr><tr><td>J</td><td>[<span class="">numeric</span>]</td><td>Matrix for residuals in measurement equations.</td></tr><tr><td>list</td><td>[<span class="">cell</span>]</td><td>List of measurement variables in rows of F, G, H, J, list of transition variables in rows of A, B, C, D, and columns of F, and list of residuals in columns of D and J; lists include all necessary lags and leads.</td></tr><tr><td>nf</td><td>[<span class="">numeric</span>]</td><td>Number of non-predetermined (forward-looking) variables in vector of transition variables.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model whose system matrices are requested.</td></tr></table><h3>Description</h3><div class="description"><p>
The unsolved system has the following form:
</p><div class="math"><span class="argument">A</span> E<sub>t</sub> [ <span class="math">xf</span><sub>t</sub> ; <span class="math">xb</span><sub>t</sub> ] + <span class="argument">B</span> [ <span class="math">xf</span><sub>t-1</sub> ; <span class="math">xb</span><sub>t-1</sub> ] + <span class="argument">C</span> + <span class="argument">D</span> <span class="math">e</span><sub>t</sub> = 0<br><span class="argument">F</span> <span class="math">y</span><sub>t</sub> + <span class="argument">G</span> <span class="math">xb</span><sub>t</sub> + <span class="argument">H</span> + <span class="argument">J</span> <span class="math">e</span><sub>t</sub> = 0
</div><p>
where <span class="math">y</span><sub>t</sub> is a vector of measurement variables, <span class="math">xf</span><sub>t</sub> and <span class="math">xb</span><sub>t</sub> are vectors of, respectively, non-predetermined (forward-looking) and predetermined (backward-looking) variables, <span class="math">e</span><sub>t</sub> is a vector of residuals, and E<sub>t</sub>[…] is a conditional expectations operator.
</p></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="tcorule" name="tcorule"><div class="topic-name-remark">Model functions</div><h2>tcorule</h2><div class="keyword-brief">Time-consistent (discretionary) optimal rule.</div><h3>Syntax</h3><pre>[this,Q,W,Qlist,Wlist,count]  = tcorule(this,uname,ueqtn,R,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model solved with optimised rule.</td></tr><tr><td>count</td><td>[<span class="">numeric</span>]</td><td>Number of iterations performed.</td></tr><tr><td>Q</td><td>[<span class="">numeric</span>]</td><td>Coefficients of optimal instrument rule, u = Q*[xb;e].</td></tr><tr><td>W</td><td>[<span class="">numeric</span>]</td><td>Coefficients of equivalent targeting rule, W*xb = 0.</td></tr><tr><td>Qlist</td><td>[<span class="">cellstr</span>]</td><td>Model variables in columns of Q.</td></tr><tr><td>Rlist</td><td>[<span class="">cellstr</span>]</td><td>Model variables in columns of R.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model for which optimal rule is to be found.</td></tr><tr><td>uname</td><td>[<span class="">cellstr</span> | <span class="">char</span>]</td><td>List of transition variables that are to be treated as instruments.</td></tr><tr><td>ueqtn</td><td>[<span class="">cellstr</span> | <span class="">char</span>]</td><td>List of transition equation lables that are to be dropped from model and replaced with optimal rules.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'beta'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1</span>]</td><td>Discount factor.</td></tr><tr><td>'ginverse'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Use generalised inverse when substituting out expectations.</td></tr><tr><td>'initexp'</td><td>[<span class="">function_handle</span> | <span class="">@eye</span>]</td><td>Initial matrix for expectations function.</td></tr><tr><td>'maxiter'</td><td>[<span class="">numeric</span> | <span class="defaultoption">50000</span>]</td><td>Maximum number of iterations allowed.</td></tr><tr><td>'tolexp'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1e-12</span>]</td><td>Termination tolerance on implied expectations function.</td></tr><tr><td>'tolrule'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1e-12</span>]</td><td>Termination tolerance on optimised policy function.</td></tr><tr><td>'tolvalue'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1e-12</span>]</td><td>Termination tolerance on value function.</td></tr></table><h3>Description</h3><div class="description"><p>
The current version of the <a href="#tcorule">tcorule</a> function assumes that the model has a correctly assigned steady state. The optimisation procedure then ignores the effect of a constant on the optimal rule. An optimal rule is returned only if it implies a unique stable solution.
</p><p>
The resulting optimal instrument rule has the following form:
</p><div class="math">
u<sub>t</sub> = <span class="argument">Q</span> [<span class="math">xb</span><sub>t</sub> ; <span class="math">e</span><sub>t</sub>]
</div>
where <span class="math">u</span><sub>t</sub> is a vector of instruments, <span class="math">xb</span><sub>t</sub> is a vector of predetermined (backward-looking) transition variables, and <span class="math">e</span><sub>t</sub> is a vector of residuals.
<p>
The resulting optimal targeting rule has the following form:
</p><div class="math"><span class="argument">W</span> <span class="math">xb</span><sub>t</sub> = 0.
</div></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="userdata" name="userdata"><div class="topic-name-remark">Model functions</div><h2>userdata</h2><div class="keyword-brief">Get or set user data attached to a model object.</div><h3>Syntax</h3><pre>x = userdata(this)
this = userdata(this,x)</pre><h3>Output arguments</h3><table><tr><td>x</td><td>[<span class="">any</span>]</td><td>User data currently contained in the model object.</td></tr><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model object with user data updated.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model object you want to get or set user data for.</td></tr></table><h3>Description</h3><div class="description"><p>You can attach any kind of user data to model objects, and retrieve or change them at any later time.</p></div><h3>Example</h3><div class="example"><p>In the example below, we assume that m is an existing model object.</p><pre>&gt;&gt; d = struct();
&gt;&gt; d.created = datestr(now());
&gt;&gt; d.description = 'This is a simple RBC model.';
&gt;&gt; m = userdata(m,d);
&gt;&gt; userdata(m)
ans = 
        created: '21-Oct-2008 02:42:24'
    description: 'This is a simple RBC model.'</pre></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="vma" name="vma"><div class="topic-name-remark">Model functions</div><h2>vma</h2><div class="keyword-brief">VMA representation of model.</div><h3>Syntax</h3><pre>[Phi,list] = vma(this,nper,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>Phi</td><td>[<span class="">numeric</span>]</td><td>Matrix with VMA representation of model.</td></tr><tr><td>list</td><td>[<span class="">cell</span>]</td><td>List of variables and list of shocks in rows and columns of Phi.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model to be converted into VMA.</td></tr><tr><td>nper</td><td>[<span class="">numeric</span>]</td><td>Order up to which VMA representation is to be computed.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="xsf" name="xsf"><div class="topic-name-remark">Model functions</div><h2>xsf</h2><div class="keyword-brief">Power spectrum and spectral density function for model variables.</div><h3>Syntax</h3><pre>[S,D,list] = xsf(this,freq,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>S</td><td>[<span class="">numeric</span>]</td><td>Power spectrum function.</td></tr><tr><td>D</td><td>[<span class="">numeric</span>]</td><td>Spectral density function.</td></tr><tr><td>list</td><td>[<span class="">cellstr</span>]</td><td>List of variables in rows and columns in S and D.</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model to be evaluated.</td></tr><tr><td>freq</td><td>[<span class="">numeric</span>]</td><td>Frequencies at which XSF is to be evaluated.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'select'</td><td>[<span class="">cellstr</span> | <span class="">char</span> | <span class="defaultoption">Inf</span>]</td><td>Return results for selected variables only.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div><div class="boxed" id="zerodb" name="zerodb"><div class="topic-name-remark">Model functions</div><h2>zerodb</h2><div class="keyword-brief">Model-specific zero database.</div><h3>Syntax</h3><pre>d = zerodb(this,range,<a href="hints-and-tips.html#optional-input-arguments">...</a>)</pre><h3>Output arguments</h3><table><tr><td>d</td><td>[<span class="">struct</span>]</td><td>Database with model variables as time series filled with zeros (for linearised variables) or ones (for log-linearised variables).</td></tr></table><h3>Input arguments</h3><table><tr><td>this</td><td>[<span class="">model</span>]</td><td>Model for which zero database is to be constructed.</td></tr><tr><td>range</td><td>[<span class="">numeric</span>]</td><td>Date range, i.e. IRIS serial date numbers, i.e. IRIS serial date numbers.</td></tr></table><h3>Optional input arguments <span style="text-decoration: underline;"></span></h3><table><tr><td>'dtrends'</td><td>[<span class="">true</span> | <span class="defaultoption">false</span>]</td><td>Measurement variables will include deterministic trends.</td></tr><tr><td>'nDraw'</td><td>[<span class="">numeric</span> | <span class="defaultoption">1</span>]</td><td>Number of randomly drawn data sets (use together with option 'residuals').</td></tr><tr><td>'residuals'</td><td>[<span class="">function_handle</span> | <span class="defaultoption">empty</span>]</td><td>Function to generate residuals.</td></tr></table><h3>Description</h3><div class="description"><p /></div><h3>Example</h3><div class="example"><pre></pre><p /></div><div class="go-to-top-of-page"><a href="#top_of_page">Top of page</a> | <a href="#list_of_keywords">List of functions</a></div></div></body></html>